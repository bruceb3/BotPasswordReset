#!/usr/bin/env perl
# vim: ft=perl

use strict;
use warnings;
use Bot;

BEGIN {
*exp_continue = *Expect::exp_continue;
*exp_continue_timeout = *Expect::exp_continue_timeout;
}


package Solaris {

    use strict; use warnings;

    sub find_os_revision {
    }

    sub unlock_users_password {
    }

    sub passhistory_file_exists {
    }

    sub reset_password {
    }

    sub remove_user_from_passhistory {

        my ($username) = shift;

        my $passhistory = '/etc/security/passhistory';
        my $tmpfile = '/tmp/bot.passhistory';

        my $remove_user_from_passhistory = RemoteCommand->new({ expect => RemCmd->expect });

        $remove_user_from_passhistory->run({
            execute => 'egrep /^$username/ $passhistory',
            error_message => 'grep failed on passhistory: ',
            failure => 'throw'
        })->run({
            execute => "sed '/^$username:/d' $passhistory > $tmpfile",
            error_message => 'sed failed on passhistory: ',
            failure => 'throw'
        })->run({
            execute => "mv $tmpfile $passhistory";
            error_message => 'failed to update passhistory: ',
            failure => 'throw'
        })->run({
            execute => "rm $tmpfile",
            error_message => 'clean up failed passhistory',
            failure => 'ignore'
        });

        return $remove_user_from_passhistory->rt;
    }

}

package RemCmd { # remote command
    my %attributes = ();

    sub _handler {
        my ($attribute, $value) = @_;
        $attributes{$attribute} = $value if (defined $value);
        return $attributes{$attribute};
    }

    sub rt {
        shift if $_[0] eq __PACKAGE__;
        return _handler('rt', @_);
    }
    sub expect {
        shift if $_[0] eq __PACKAGE__;
        return _handler('expect', @_);
    }
}


sub Bot::hook {
    my ($expect, $hostname) = @_;
    my $rt;

    my $user = 'szbrhv';
    my $password = 'foobar1003';

    $rt = $expect->execute({ command => 'uname -s' });
    if ($rt->ok) {
        if ($rt->first_line eq 'AIX') {
            $rt = AIX::reset_password($expect, $user, $password);
            $rt = $expect->execute({ command => "pwdadm -c $user" });
        }
        elsif ($rt->first_line eq 'SunOS') {
            RemCmd->expect($expect);
            try {
                my $os_revision = Solaris::find_os_revision();
                if ( $os_revision eq '5.10' ) {
                    Solaris::unlock_users_password();
                }
                if ( Solaris::passhistory_file() ) {
                    Solaris::remove_user_from_passhistory();
                }
                Solaris::reset_password();
            } catch {
            } finally {
                return RemCmd->rt();
            }
        }

        elsif ($rt->first_line eq 'HP-UX') {
            $rt = ::hp_reset_password($expect, $user, $password);
        }
        elsif ($rt->first_line eq 'Linux') {
            $rt = ::reset_password($expect, $user, $password);
        }
        else {
        }
    }
    return $rt;
}

package RemoteCommand;
use Mouse;
use strict;
use warnings;

use Carp;

has 'expect' => (
    is => 'rw',
    default => sub { croak "No expect instance supplied" },
);

has 'command' => (
    is => 'rw',
    default => sub { croak "No command supplied" },
);

has 'error_message' => (
    is => 'rw',
    default => 'No error message supplied',
);

has 'failed' => (
    is => 'rw',
    default => sub { }, # by default the failed handler does nothing.
);

sub execute { 
    my $self = shift;
    my $rt = RemCmd->rt( $self->execute({ command => $self->command }) );
    $self->failed()->($self->expect, $rt) if not $rt->worked;
    return $rt;
}

package main;


sub hp_reset_password {
}

sub reset_password {
    my ($expect, $username, $password) = @_;
    my $number_of_passwords_given = 0;

    $expect->send("passwd $username");
    $expect->expect( 
        [ qr/[nN]ew [pP]assword:/m, sub {
                my ($pty) = @_;
                $number_of_passwords_given++;
                $pty->send($password);
                return exp_continue;
            }, $expect ],

        [ qr/Re-enter New password:/m, sub {
                my ($pty) = @_;
                $number_of_passwords_given++;
                $pty->send($password);
                return;
            }, $expect ]
    );
    my $status = $expect->wait_for_shell_prompt;
    return $status;
}
